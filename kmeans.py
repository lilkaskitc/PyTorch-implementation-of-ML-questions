# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y26ZOuT96i7uA5hh_8UwDOEBoi54v-Q1
"""

import torch

class KMeans:
    def __init__(self, n_clusters=3, max_iters=100, tol=1e-4, device=None, verbose=False):
        self.n_clusters = n_clusters
        self.max_iters = max_iters
        self.tol = tol
        self.verbose = verbose
        self.device = device or ('cuda' if torch.cuda.is_available() else 'cpu')
        self.centroids = None

    def fit(self, X):
        X = X.to(self.device)
        n_samples, n_features = X.shape

        # Randomly initialize centroids from data points
        indices = torch.randperm(n_samples)[:self.n_clusters]
        self.centroids = X[indices]

        for i in range(self.max_iters):
            # Compute distances to centroids
            distances = torch.cdist(X, self.centroids, p=2)

            # Assign each sample to the nearest centroid
            labels = torch.argmin(distances, dim=1)

            # Compute new centroids
            new_centroids = torch.stack([
                X[labels == k].mean(dim=0) if (labels == k).sum() > 0 else self.centroids[k]
                for k in range(self.n_clusters)
            ])

            # Check for convergence
            shift = torch.norm(self.centroids - new_centroids, dim=1).sum().item()
            if self.verbose:
                print(f"Iter {i+1}/{self.max_iters} | centroid shift = {shift:.6f}")

            if shift < self.tol:
                if self.verbose:
                    print("Converged.")
                break

            self.centroids = new_centroids

        self.labels_ = labels
        return self

    def predict(self, X):
        X = X.to(self.device)
        distances = torch.cdist(X, self.centroids, p=2)
        return torch.argmin(distances, dim=1).cpu()

    def fit_predict(self, X):
        self.fit(X)
        return self.labels_.cpu()

# Example with synthetic data
from sklearn.datasets import make_blobs
import matplotlib.pyplot as plt

# Generate toy data
X_np, y_true = make_blobs(n_samples=500, centers=3, cluster_std=0.7, random_state=42)
X = torch.tensor(X_np, dtype=torch.float32)

# Run K-Means
kmeans = KMeans(n_clusters=3, max_iters=100, verbose=True)
y_pred = kmeans.fit_predict(X)

# Plot
plt.scatter(X_np[:, 0], X_np[:, 1], c=y_pred, s=30, cmap='viridis')
plt.scatter(kmeans.centroids[:, 0].cpu(), kmeans.centroids[:, 1].cpu(),
            s=200, c='red', marker='X')
plt.title("PyTorch K-Means Clustering")
plt.show()